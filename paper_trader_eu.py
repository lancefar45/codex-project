from ib_insync import *
import time
import datetime as dt
import os
import glob
import csv
from decimal import Decimal, ROUND_HALF_UP
from zoneinfo import ZoneInfo

# ===============================
# CONFIG
# ===============================
HOST = "127.0.0.1"
PORT = 7497
CLIENT_ID = 2  # EU script - brug et andet ID end US script

# Trading behaviour
CAPITAL_PER_TRADE_EUR = 25000
MAX_OPEN_POSITIONS = 35
LOOP_SECONDS = 15

# Strategy thresholds
MIN_SCORE = 0.62
BAR_SIZE = "5 mins"
DURATION = "2 D"
USE_RTH = True

# Risk model (ATR based bracket)
TAKE_PROFIT_ATR = 1.2
STOP_LOSS_ATR = 0.9
ATR_LEN = 14

# Order placement
ALLOW_ADD_TO_EXISTING_POSITIONS = True
MAX_POSITION_PER_SYMBOL = 0  # 0 = unlimited (shares)

# EU market hours (rough, CET/CEST) for stocks
EU_TZ = ZoneInfo("Europe/Copenhagen")
EU_OPEN = dt.time(9, 0)
EU_CLOSE = dt.time(17, 25)

# Safety / throttling
MAX_NEW_TRADES_PER_LOOP = 2   # sÃ¦t 0 for ingen cap
SLEEP_BETWEEN_ORDERS = 0.8

# CSV whitelist file pattern (generated by your scan)
EU_SCAN_OK_PATTERN = "eu_scan_ok_*.csv"

# Fallback list if no scan file found (can be empty)
FALLBACK_EU = [
    # symbol, currency, primaryExchange
    ("SAP", "EUR", "IBIS"),
    ("SIE", "EUR", "IBIS"),
    ("VOW3", "EUR", "IBIS"),
    ("BMW", "EUR", "IBIS"),
    ("AIR", "EUR", "SBF"),
    ("MC", "EUR", "SBF"),
]

# ===============================
# CONNECT
# ===============================
def connect_ib():
    ib = IB()
    for i in range(10):
        try:
            print(f"Connecting to IBKR... attempt {i+1}")
            ib.connect(HOST, PORT, clientId=CLIENT_ID)
            if ib.isConnected():
                print("Connected.")
                return ib
        except Exception as e:
            print(f"Connect failed: {e}")
            time.sleep(2)
    raise RuntimeError("Could not connect to IBKR (TWS running + API enabled?)")

# ===============================
# TIME HELPERS
# ===============================
def eu_market_open_now():
    now = dt.datetime.now(EU_TZ)
    if now.weekday() >= 5:
        return False
    t = now.time()
    return (t >= EU_OPEN) and (t < EU_CLOSE)

# ===============================
# DATA + MATH HELPERS
# ===============================
def _dec(x) -> Decimal:
    return Decimal(str(x))

def sma(values, length):
    if len(values) < length:
        return None
    return sum(values[-length:]) / length

def true_range(h, l, prev_close):
    return max(h - l, abs(h - prev_close), abs(l - prev_close))

def atr_from_bars(bars, length=14):
    if len(bars) < length + 1:
        return None
    trs = []
    for i in range(1, len(bars)):
        tr = true_range(bars[i].high, bars[i].low, bars[i-1].close)
        trs.append(tr)
    if len(trs) < length:
        return None
    return sum(trs[-length:]) / length

def tick_from_market_rule(price: float, rule_increments):
    """
    rule_increments: list of PriceIncrement(lowEdge, increment)
    choose increment for the highest lowEdge <= price
    """
    if not rule_increments:
        # fallback (better than 0.0001)
        return 0.01
    p = float(price)
    best = None
    for inc in rule_increments:
        if p >= float(inc.lowEdge):
            if best is None or float(inc.lowEdge) >= float(best.lowEdge):
                best = inc
    return float(best.increment) if best else float(rule_increments[0].increment)

def round_to_tick_decimal(price: float, tick: float) -> float:
    """
    Use Decimal rounding to avoid float artifacts that trigger Error 110.
    """
    if tick is None or tick <= 0:
        return float(_dec(price).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP))
    p = _dec(price)
    t = _dec(tick)
    n = (p / t).to_integral_value(rounding=ROUND_HALF_UP)
    return float(n * t)

def position_size(price_eur):
    if price_eur is None or price_eur <= 0:
        return 0
    qty = int(CAPITAL_PER_TRADE_EUR / float(price_eur))
    return max(1, qty)

# ===============================
# WHITELIST LOADING
# ===============================
def load_latest_eu_whitelist():
    files = sorted(glob.glob(EU_SCAN_OK_PATTERN))
    if not files:
        return FALLBACK_EU, None

    latest = files[-1]
    items = []
    try:
        with open(latest, "r", newline="", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            # We try common column names:
            # symbol, currency, primaryExchange (or primary_exchange)
            for row in reader:
                sym = (row.get("symbol") or row.get("Symbol") or "").strip()
                cur = (row.get("currency") or row.get("Currency") or row.get("cur") or "").strip()
                prim = (row.get("primaryExchange") or row.get("primary_exchange") or row.get("PrimaryExchange") or row.get("primary") or "").strip()
                if not sym or not cur:
                    continue
                if not prim:
                    # If primary exchange is missing, SMART may still qualify, but EU is trickier.
                    # We'll keep it and let contractDetails decide, but you may see more rejects.
                    prim = ""
                items.append((sym, cur, prim))
    except Exception as e:
        print(f"Could not read {latest}: {e}")
        return FALLBACK_EU, None

    # de-dup
    seen = set()
    cleaned = []
    for sym, cur, prim in items:
        key = (sym, cur, prim)
        if key in seen:
            continue
        seen.add(key)
        cleaned.append((sym, cur, prim))

    return cleaned if cleaned else FALLBACK_EU, latest

# ===============================
# ORDER / PORTFOLIO HELPERS
# ===============================
def current_positions_by_symbol(ib):
    d = {}
    for p in ib.positions():
        try:
            sym = p.contract.symbol
            d[sym] = d.get(sym, 0) + float(p.position)
        except Exception:
            continue
    return d

def has_open_order_for_symbol(ib, symbol: str) -> bool:
    """
    True if there is any open trade (Submitted/PreSubmitted/PendingSubmit) for that symbol.
    """
    for tr in ib.openTrades():
        try:
            if tr.contract and tr.contract.symbol == symbol:
                st = (tr.orderStatus.status or "").lower()
                if st in ("presubmitted", "submitted", "pendingsubmit", "pendingcancel"):
                    return True
        except Exception:
            continue
    return False

def open_positions_count(ib):
    return sum(1 for p in ib.positions() if abs(float(p.position)) > 0.000001)

# ===============================
# STRATEGY + SCORE
# ===============================
def score_contract(ib, contract):
    """
    Simple but practical quality-score for EU:
    - Trend: SMA10 vs SMA30
    - Momentum: last close vs SMA30
    - Volatility sanity: ATR as % of price (avoid super dead or insane)
    Returns: (score, last_price, atr)
    """
    try:
        bars = ib.reqHistoricalData(
            contract,
            endDateTime="",
            durationStr=DURATION,
            barSizeSetting=BAR_SIZE,
            whatToShow="TRADES",
            useRTH=USE_RTH,
            formatDate=1
        )
    except Exception:
        return None, None, None

    if not bars or len(bars) < 60:
        return None, None, None

    closes = [b.close for b in bars]
    price = closes[-1]
    sma10 = sma(closes, 10)
    sma30 = sma(closes, 30)
    if sma10 is None or sma30 is None or price is None:
        return None, None, None

    atr = atr_from_bars(bars, ATR_LEN)
    if atr is None or atr <= 0:
        return None, None, None

    # Components mapped to 0..1
    trend = 1.0 if sma10 > sma30 else 0.0
    momentum = max(0.0, min(1.0, (price / sma30 - 1.0) / 0.01))  # 1% above sma30 ~ full
    atr_pct = atr / price

    # Prefer "normal" intraday vol range for entries
    # 0.3%..2.5% ATR% is decent. Outside that reduces score.
    if atr_pct < 0.003:
        vol_score = atr_pct / 0.003  # 0..1
    elif atr_pct > 0.025:
        vol_score = max(0.0, 1.0 - (atr_pct - 0.025) / 0.02)  # fade to 0
    else:
        vol_score = 1.0

    # Combine
    score = (0.45 * trend) + (0.35 * momentum) + (0.20 * vol_score)
    return float(score), float(price), float(atr)

# ===============================
# BRACKET ORDER (EU tick-safe)
# ===============================
def place_bracket(ib, contract, qty, entry_price, atr_val, rule_increments):
    """
    Parent Market BUY + TP Limit SELL + SL Stop SELL
    Tick sizes derived from Market Rule increments.
    """
    tp_raw = entry_price + TAKE_PROFIT_ATR * atr_val
    sl_raw = entry_price - STOP_LOSS_ATR * atr_val
    if sl_raw <= 0:
        return False

    tp_tick = tick_from_market_rule(tp_raw, rule_increments)
    sl_tick = tick_from_market_rule(sl_raw, rule_increments)

    tp = round_to_tick_decimal(tp_raw, tp_tick)
    sl = round_to_tick_decimal(sl_raw, sl_tick)

    parent = MarketOrder("BUY", qty)
    parent.tif = "DAY"
    parent.transmit = False

    tp_order = LimitOrder("SELL", qty, tp)
    tp_order.tif = "DAY"
    tp_order.transmit = False

    sl_order = StopOrder("SELL", qty, sl)
    sl_order.tif = "DAY"
    sl_order.transmit = True

    try:
        parent_trade = ib.placeOrder(contract, parent)
        ib.sleep(0.25)
        parent_id = parent_trade.order.orderId

        tp_order.parentId = parent_id
        sl_order.parentId = parent_id

        ib.placeOrder(contract, tp_order)
        ib.placeOrder(contract, sl_order)
        return True
    except Exception as e:
        print(f"place_bracket failed for {contract.symbol}: {e}")
        return False

# ===============================
# MAIN
# ===============================
def main():
    ib = connect_ib()
    accounts = ib.managedAccounts()
    acct = accounts[0] if accounts else "UNKNOWN"
    print(f"Managed account: {acct}")

    eu_items, src = load_latest_eu_whitelist()
    if src:
        print(f"Loaded EU whitelist from: {src}")
    else:
        print("Loaded EU whitelist from fallback list (no scan csv found).")

    # Build + qualify contracts and fetch market rules
    eu_contracts = {}
    eu_rules = {}

    ok = 0
    for sym, cur, prim in eu_items:
        c = Stock(sym, "SMART", cur, primaryExchange=prim) if prim else Stock(sym, "SMART", cur)
        try:
            cds = ib.reqContractDetails(c)
            if not cds:
                continue

            cd = cds[0]
            ib.qualifyContracts(c)
            eu_contracts[sym] = c

            rule_ids = (cd.marketRuleIds or "").strip()
            rule_list = []
            if rule_ids:
                first_rule = int(rule_ids.split(",")[0])
                rule_list = ib.reqMarketRule(first_rule) or []
            eu_rules[sym] = rule_list
            ok += 1
        except Exception:
            continue

    print(f"Qualified EU: {ok}")
    print("EU LOOP STARTED")
    print(
        f"CAPITAL_PER_TRADE_EUR={CAPITAL_PER_TRADE_EUR} | "
        f"MAX_OPEN_POSITIONS={MAX_OPEN_POSITIONS} | MIN_SCORE={MIN_SCORE:.2f} | "
        f"ADD_TO_POSITION={'ON' if ALLOW_ADD_TO_EXISTING_POSITIONS else 'OFF'}"
    )

    while True:
        try:
            if not eu_market_open_now():
                print("EU market closed. Sleeping...")
                time.sleep(60)
                continue

            pos_count = open_positions_count(ib)
            if pos_count >= MAX_OPEN_POSITIONS:
                print("Max positions reached. Sleeping.")
                time.sleep(LOOP_SECONDS)
                continue

            pos_by_sym = current_positions_by_symbol(ib)

            # Score and rank
            ranked = []
            for sym, c in eu_contracts.items():
                if has_open_order_for_symbol(ib, sym):
                    continue

                if (not ALLOW_ADD_TO_EXISTING_POSITIONS) and (abs(pos_by_sym.get(sym, 0)) > 0):
                    continue

                if MAX_POSITION_PER_SYMBOL > 0:
                    if abs(pos_by_sym.get(sym, 0)) >= MAX_POSITION_PER_SYMBOL:
                        continue

                score, price, atr = score_contract(ib, c)
                if score is None or price is None or atr is None:
                    continue

                if score >= MIN_SCORE:
                    ranked.append((score, sym, c, price, atr))

            ranked.sort(reverse=True, key=lambda x: x[0])

            if not ranked:
                print("No ranked candidates. Sleeping.")
                time.sleep(LOOP_SECONDS)
                continue

            placed = 0
            for score, sym, c, price, atr in ranked:
                if MAX_NEW_TRADES_PER_LOOP and placed >= MAX_NEW_TRADES_PER_LOOP:
                    break

                # Re-check position cap after each placement
                pos_count = open_positions_count(ib)
                if pos_count >= MAX_OPEN_POSITIONS:
                    break

                qty = position_size(price)
                if qty <= 0:
                    continue

                # If you want to "buy heavier", increase CAPITAL_PER_TRADE_EUR
                rules = eu_rules.get(sym, [])
                print(f"BUY {sym} (EU) score={score:.2f} price={price:.2f} qty={qty} rules={'yes' if rules else 'no'}")

                ok = place_bracket(ib, c, qty, price, atr, rules)
                if ok:
                    placed += 1
                ib.sleep(SLEEP_BETWEEN_ORDERS)

            time.sleep(LOOP_SECONDS)

        except KeyboardInterrupt:
            print("CTRL+C received. Stopping.")
            break
        except Exception as e:
            print(f"Loop error: {e}")
            time.sleep(3)

    ib.disconnect()
    print("DONE")

if __name__ == "__main__":
    main()
